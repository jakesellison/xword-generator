---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
library(profvis)
library(gtools)
```

```{r}
#compute the score of a word by the weighting of the table
score_word <- function(word,freq){
  char_list <- strsplit(word,"")[[1]]
  score<-c(rep(0,length(char_list)))
  for (i in 1:length(char_list)){
    for (j in 1:length(char_list)) {
      score[i] <- score[i] + freq[[i]][match(char_list[[j]], freq[[i]]$x),2]
    }
  }
  return(score)
}

#score every word based on frequency of letter positions
scorecard_init <- function(dict, freq, dim){
  scorecard <- data.frame(cbind(dict, do.call(rbind, data.frame(lapply(dict, score_word, freq)))))
  #rownames(scorecard) <- NULL
  #scorecard$word <- as.character(scorecard$word)
  scorecard <- scorecard %>% mutate_at(c(1:dim+1),function(x){as.numeric(as.character(x))})
  return(scorecard)
}

#initialize the dictionary
dict_init <- function(dim){
  full_dict <- qdapDictionaries::DICTIONARY
  dict5 <- mutate(full_dict, nchar = nchar(word)) %>% 
    filter(nchar == dim)
  dict <- dict5$word
  dict <- tolower(dict)
  dict <- dict[stringi::stri_detect_regex(dict,"^[a-z]+$")]
  return(dict)
}

#for each column in the puzzle, create a dict list ordered by score
gen_score_dict <- function(scorecard) {
  scored_dict <- c()
  for(i in 1:(ncol(scorecard)-1)) {
    score_col <- data.frame(word = scorecard[,1], score = scorecard[,i+1]) %>% 
      arrange(desc(score))
    scored_dict <- append(scored_dict,list(as.character(score_col[,1])))
  }
  return(lapply(scored_dict, function(x){lapply(x, function(y){strsplit(y,"")[[1]]})}))
}
 
#generate a frequency table showing how likely a given word is to appear in a square
freq_init <- function(dict){
  freq <- t(data.frame(lapply(dict, strsplit, "")))
  freq <- apply(freq, 2, function(x){data.frame(table(x)[order(table(x), decreasing = TRUE)])})
  return(freq)
}
```


```{r}
find_word <- function(clue_matrix,stack_dict,dim,clues){
  i <- 1
  while (i <= length(stack_dict)) {
    if(is.null(stack_dict[[1]])){break}
    split_word <- stack_dict[[i]]
    word <- paste(split_word,collapse='')
    if(word %in% clues){
      i <- i+1
      next
    }
    clues <- append(clues,word)
    try <- apply(cbind(clue_matrix,split_word), 1, test_word, clues, dim)
    if(!FALSE %in% try){
      if((i+1)> length(stack_dict)){
        return(list(stack_dict[1],list(list(NULL)),TRUE))
      } else {
        return(list(stack_dict[1],list(stack_dict[(i+1):length(stack_dict)]),TRUE))
      }
    }
    clues <- clues[1:length(clues)-1]
    for (k in 1:dim) {
      if(try[k] == TRUE){next}
      letter <- split_word[k]
      stack_dict <- stack_dict[sapply(stack_dict, subset_dict, letter, k, clues, word)]
      if(length(stack_dict)  == 0){
        break
      }
    }
    i <- 1
  }
  return(c(FALSE,FALSE,FALSE))
}

#test letter at pos in dict
subset_dict <- function(word, letter, pos, clues, qword){
  if(word[pos] == letter){
    if(!FALSE %in% (word == c('l','e','v','e','e')) & length(clues) == 1){
      browser()
    }
    FALSE
  } else {
    TRUE
  }
}

test_word <- function(frag,clues,dim){
  mat_index <- matrix(c(sapply(frag,char_to_num),rep(1,dim))[1:dim], nrow = 1, ncol = dim)
  frag_possibilities <- frag_array[mat_index][[1]]
  if(length(frag_possibilities[!frag_possibilities %in% clues]) > 0){
    return(TRUE)
  } else {
    return(FALSE)
  }
}
```

```{r}
#experimenting with memory for time savings
explode_dict <- function(dict_all){
  do.call(c,lapply(dict_all, explode_word))
}
                   
explode_word <- function(x){
  split_out <- c()
  for (i in 1:nchar(x)){
    split_out <- append(split_out, substr(x,1,i))
  }
  return(split_out)
}

char_to_num <- function(x){
  if(x == ""){return(1)}
  as.numeric(charToRaw(x))-95
}

# need this to be an n-dimensional array, where at each index, I have saved a list of all possible words that start with the fragment represented by that index.
populate_frag_array <- function(dict, frag_array, dim) {
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      dim_index <- sapply(strsplit(frag,"")[[1]], char_to_num)
      dim_matrix <- matrix(c(dim_index,rep(1,dim))[1:dim], nrow = 1, ncol = dim)
      #index array using a matrix w/1 row, dim # of cols, and each val is an index in the dimension
      frag_array[dim_matrix][[1]] <- c(frag_array[dim_matrix][[1]],word)
    }
  }
  return(frag_array)
}
```

```{r}
main <- function(seed, dim){
  clue_matrix <- matrix(strsplit(seed,"")[[1]],nrow=dim,ncol=1,byrow = FALSE)
  clues <- seed
  while(length(clues) != dim){
    depth <- length(clues) + 1
    if(length(stack_dict) < 5){browser()}
    if(depth == 2){
      message(paste(length(stack_dict[[2]])))
    }
    search_tpl <- find_word(clue_matrix,stack_dict[[depth]],dim,clues)
    if(search_tpl[[3]][[1]] == FALSE & depth == 2){
      return(FALSE)
    } else if (search_tpl[[3]][[1]] == FALSE) {
      stack_dict[[depth]] <- score_dict[[depth]]
      depth <- depth-1
      clues <- clues[1:depth-1]
      clue_matrix <- clue_matrix[,c(1:(ncol(clue_matrix)-1))]
    } else {
      if(is.null(search_tpl[[2]][[1]])){browser()}
      stack_dict[[depth]] <- search_tpl[[2]][[1]]
      clue_matrix <- cbind(clue_matrix, search_tpl[[1]][[1]])
      clues <- append(clues, paste(search_tpl[[1]][[1]],collapse=''))
    }
  }
  return(clue_matrix)
}
```

```{r}
# global vars...

init_global_vars <- function(seed,dim){

  dict_all <<- dict_init(dim)
  freq <<- freq_init(dict_all)
  scorecard <<- scorecard_init(dict_all,freq,dim)
  score_dict <<- gen_score_dict(scorecard)
  stack_dict <<- score_dict

  frags <<- explode_dict(dict_all)
  mstr_frag_array <<- array(list(NULL),rep(27,dim))
  mstr_frag_array <<- populate_frag_array(dict_all, mstr_frag_array, dim)
  frag_array <<- mstr_frag_array
}

# for testing...

seed <- 'spasm'

init_global_vars(seed,5)
start_time <- Sys.time()
main(seed, 5)
end_time <- Sys.time()
end_time - start_time

```
```{r}
start <- Sys.time()
brute_force(5)
end <- Sys.time()
end - start
```


```{r}
puzzle_master <<- c()

slice_dict <- function(dict_all){
  do.call(c,lapply(dict_all, strsplit, ""))
}

bf_tester <- function(bf_mat, dim) {
  clues <- apply(bf_mat, 2, paste, collapse = "")
  valid <- apply(bf_mat, 1, bf_try, clues, dim)
  if(!FALSE %in% valid){
    puzzle_master <<- bf_mat
  }
}

bf_try <- function(bf_row, clues, dim){
  mat_index <- matrix(sapply(bf_row,char_to_num), nrow = 1, ncol = dim)
  frag_possibilities <- frag_array[mat_index][[1]]
  if(length(frag_possibilities[!frag_possibilities %in% clues]) > 0){
    return(TRUE)
  } else {
    return(FALSE)
  }
}

brute_force <- function(dim = 5){
  slices <<- slice_dict(dict_init(dim))
  for (word1 in slices) {
    for (word2 in slices) {
      for (word3 in slices) {
        for (word4 in slices) {
          for (word5 in slices) {
            bf_tester(cbind(word1,word2,word3,word4,word5), dim)
            if(!is.null(puzzle_master)){
              return(puzzle_master)
            }
          }
        }
      }
    }
  }
}
```




