---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
library(profvis)
library(gtools)
library(hash)
options(expressions = 500000)
```

```{r}
#initialize the dictionary
dict_init <- function(word_len_list){
  dict <- qdapDictionaries::DICTIONARY
  dict <- dict %>% 
    mutate(char_num = nchar(word),
           word = tolower(word)) %>% 
    filter(stringi::stri_detect_regex(dict$word,"^[a-z]+$"))
  stack_dict <- c()
  for (k in 1:length(word_len_list)) {
    stack_dict <- append(stack_dict, list(sample(filter(dict, char_num == word_len_list[k])$word)))
  }
  return(stack_dict)
}
```

```{r}
explode_word <- function(x){
  split_out <- c()
  for (i in 1:nchar(x)){
    split_out <- append(split_out, substr(x,1,i))
  }
  return(split_out)
}

slice_dict <- function(dict){
  stack_dict <- c()
  col_lengths <- apply(clue_matrix, 2, function(x){length(x[!is.na(x)])})
  for(i in 1:ncol(clue_matrix)){
    stack_dict <- append(stack_dict, list(dict[[i]][nchar(dict[[i]]) == col_lengths[i]]))
  }
  return(stack_dict)
}

# need this to be an n-dimensional array, where at each index, I have saved a list of all possible words that start with the fragment represented by that index.
populate_frag_hash <- function(stack_dict) {
  #initialize
  frag_hash <- hash()
  dict <- unique(unlist(stack_dict))
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      for (i in nchar(frag):dims){
        pathfinder <- list(words = c(), valid = c())
        .set(frag_hash, paste(frag,i,sep=''), pathfinder)
      }
    }
  }
  #populate
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      for (i in nchar(frag):dims){
        if(nchar(word) == i){
          words_list <- append(frag_hash[[ paste(frag,i,sep='') ]]$words, word)
          pathfinder <- list(words = words_list, valid = c())
          .set(frag_hash, paste(frag,i,sep=''), pathfinder)
        }
      }
    }
  }
  #calculate
  keys <- hash::keys(frag_hash)
  for (key in keys) {
    next_index <- nchar(gsub("^([a-z]+)+[0-9]+$", "\\1", key))+1
    words_list <- frag_hash[[ key ]]$words
    if(is.null(words_list)){
      valid_list <- NULL
    } else {
      valid_list <- table(sapply(words_list, stringi::stri_sub, next_index, next_index))
    }
    pathfinder <- list(words = words_list, valid = valid_list)
    .set(frag_hash, key, pathfinder)
  }
  return(frag_hash)
}
```

```{r}
write_word <- function(word, depth, type = 'str'){
  #browser()
  if(type == 'str'){
    word <- strsplit(word, "")[[1]]
  }
  for(i in depth:length(puzz)){
    if(!is.na(puzz[i]) & puzz[i] == "?"){
      depth <- i
      break
    }
  }
  for(i in 0:(length(word)-1)){
    puzz[i+depth] <<- word[i+1]
  }
  return(depth+i)
}

rm_word <- function(depth){
  #browser()
  rm_to <- depth - ((depth-1) %% dims)
  for(i in depth:rm_to){
    if(is.na(puzz[i])){
      i <- i + 1
      break
    } else {
      puzz[i] <<- "?"
    }
  }
  return(i-1)
}

#read all across words through 
read_across <- function(depth){
  return(unlist(lapply(seq(1,dims), function(x){
    #browser()
    row <- puzz[seq(x,length(puzz),dims)]
    row <- unlist(strsplit(paste(row,collapse=''),'NA'))
    tot_length <- 0
    for(i in 1:length(row)){
      tot_length <- tot_length + nchar(row[i])
      if(tot_length > ceiling(depth/dims)){
        return(row[i])
      }
    }
  })))
}

length(m)
puzz <<-c(NA,2,3,4,NA,6,7,8,NA)
read_across(3)


puzz
depth <- 6
puzz[seq(3,depth,3)]

# depth <- 1
# dims <<- 3
# depth <- write_word('xx', depth, 'str')
# puzz
# rm_word(8)
# puzz <<-c(NA,'','','',NA,'','','',NA)
# puzz
# #writes a word to global_var clue_matrix
# write_word <- function(word, depth, type = 'list'){
#   if (type == 'str') {
#     word <- strsplit(word,"")[[1]]
#   }
#   col <- clue_matrix[,depth]
#   write_pos <- 0
#   for(i in 1:length(col)){
#     if(!is.na(col[i]) & col[i] == "") {
#       break
#     }
#   }
#   pos <- i
#   for (i in 1:length(word)) {
#     clue_matrix[pos,depth] <<- word[i]
#     pos <- pos + 1
#   }
# }
# 
# #reads a word from global_var clue_matrix
# read_word <- function(depth, dir = 1, type = 'list'){ #if dir = 2, then read across
#   if(dir == 1) {
#     col <- clue_matrix[,depth]
#   } else {
#     col <- clue_matrix[depth,]
#   }
#   for(i in (length(col)-1):1){
#     if(is.na(col[i]) & col[i+1] != "") {
#       i <- i+1
#       break
#     }
#   }
#   pos <- i
#   reader <- c()
#   while(!is.na(col[pos]) & pos <= length(col) & col[pos] != "") {
#     reader <- append(reader, col[pos])
#     pos <- pos + 1
#   }
#   if(type == 'str'){
#     reader <- paste(reader, collapse ='')
#   }
#   return(reader)
# }
# 
# #remove a word from global_var clue_matrix
# rm_word <- function (depth) {
#   col <- clue_matrix[,depth]
#   for(i in length(col):1){
#     if(is.na(col[i]) & col[i+1] != "") {
#       i <- i+1
#       break
#     }
#   }
#   rm_pos <- i
#   while(!is.na(col[rm_pos]) & rm_pos <= length(col)) {
#     clue_matrix[rm_pos,depth] <<- ""
#     rm_pos <- rm_pos + 1
#   }
# }
```

```{r}
subset_dict <- function(across, req_char, dict, down, depth){
  browser()
  req_char <- sapply(across, length)
  across <- sapply(across, function(x){x[x!='?']})
  valid_list <- c()
  for(i in 1:length(across)){
    if(across[i] == ''){
      next
    }
    words <- frag_hash[[paste(across[i],req_char[i],sep='')]]$words
    words  <- words[!words %in% down]
    if(rlang::is_empty(words)) {
      valid <- NULL
    } else {
      valid <- names(table(sapply(words, stringi::stri_sub, nchar(across[i])+1, nchar(across[i])+1)))
    }
    valid_list <- append(valid_list, list(valid))
  }
  #limit dict to only valid words
  for (i in 1:length(valid_list)){
    dict <- dict[substr(dict,i,i) %in% valid_list[[i]]]
  }
  return(dict)
}

main <- function(){
  browser()
  while(depth <= length(stack_dict)){ #depth is the index progress through stack_dict
    
    if(depth == 2){
      message(paste(length(stack_dict[[1]])))
    }
    across <- read_across(depth)
    stack_dict[[depth]] <- subset_dict(across,req_char,stack_dict[[depth]],down,depth) #returns a list of all valid words
    stack_dict[[depth]][!stack_dict[[depth]] %in% down] #remove existing clues
    
    for(i in depth:1){
      if(rlang::is_empty(stack_dict[[i]])){ #out of dict words at this level
        stack_dict[[i]] <- mstr_dict[[i]]
        depth <- rm_word(depth)
        if(depth == 0) {return(clue_matrix)} #search has failed
        down <- down[-length(down)]
      } else {
        break
      }
    }
    candidate <- stack_dict[[depth]][1]
    stack_dict[[depth]] <- stack_dict[[depth]][-1] # remove the chosen word from dict
    depth <- write_word(candidate, depth, type = 'str')
    down <- c(down, candidate)
  }
  return(clue_matrix)
}
```

```{r}
dims<<-3
puzz <<- rep("?",9)
depth <<- write_word('war', 1, type = 'str')
stack_dict <<- dict_init(c(3,3,3))
mstr_dict <<- stack_dict
frag_hash <<- populate_frag_hash(stack_dict)
puzz
```

```{r}
start_time <- Sys.time()
main()
end_time <- Sys.time()
end_time - start_time
```

