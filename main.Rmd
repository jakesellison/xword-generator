---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
library(profvis)
library(gtools)
library(hash)
```

```{r}
#compute the score of a word by the weighting of the table
score_word <- function(word,freq){
  char_list <- strsplit(word,"")[[1]]
  score<-c(rep(0,length(char_list)))
  for (i in 1:length(char_list)){
    for (j in 1:length(char_list)) {
      score[i] <- score[i] + freq[[i]][match(char_list[[j]], freq[[i]]$x),2]
    }
  }
  return(score)
}

#score every word based on frequency of letter positions
scorecard_init <- function(dict, freq, dim){
  scorecard <- data.frame(cbind(dict, do.call(rbind, data.frame(lapply(dict, score_word, freq)))))
  #rownames(scorecard) <- NULL
  #scorecard$word <- as.character(scorecard$word)
  scorecard <- scorecard %>% mutate_at(c(1:dim+1),function(x){as.numeric(as.character(x))})
  return(scorecard)
}

#initialize the dictionary
dict_init <- function(dim, wl = NULL){
  if(is.null(wl)){
    full_dict <- qdapDictionaries::DICTIONARY
  } else {
    full_dict <- wl
  }
  dict <- mutate(full_dict, char_num = nchar(word)) %>% 
    filter(char_num <= dim)
  dict <- dict$word
  dict <- tolower(dict)
  dict <- dict[stringi::stri_detect_regex(dict,"^[a-z]+$")]
  return(dict)
}

#for each column in the puzzle, create a dict list ordered by score
gen_score_dict <- function(scorecard) {
  scored_dict <- c()
  for(i in 1:(ncol(scorecard)-1)) {
    score_col <- data.frame(word = scorecard[,1], score = scorecard[,i+1]) %>% 
      arrange(desc(score))
    scored_dict <- append(scored_dict,list(as.character(score_col[,1])))
  }
  return(lapply(scored_dict, function(x){lapply(x, function(y){strsplit(y,"")[[1]]})}))
}
 
#generate a frequency table showing how likely a given word is to appear in a square
freq_init <- function(dict){
  freq <- t(data.frame(lapply(dict, strsplit, "")))
  freq <- apply(freq, 2, function(x){data.frame(table(x)[order(table(x), decreasing = TRUE)])})
  return(freq)
}
```

```{r}
# considerations for implementing black squares:
# 
#   dim can't be the measure that I test by, I will need a new way to measure the length of word to choose*
#   
#   should create a static matrix that I update, and I pass along my current pos rather than cbind on rows
# 
#   > get a down word that is correct length
#     - it can start one (or more) char short
#     - it can end one (or more) char short
#   > test appropriately for across word. 
#     - it can end early
#     - it can start early
#     
#   I should look down the col and determine the length of word to use
#   THEN add that word to the matrix, offsetting by black squares
#   THEN run test_word
#     IN TEST WORD if 
  
```

```{r}
#writes a word to global_var clue_matrix
write_word <- function(word,depth,type = 'list'){
  if(type == 'str'){
    word <- strsplit(word,"")[[1]]
  }
  col <- clue_matrix[,depth]
  top_box <- 1
  bottom_box <- length(col)
  for(i in 1:length(col)){
    #look for first black box until I reach depth
    if(is.na(col[i]) & top_box == i){
      top_box <- i+1
    }
    #past depth, find the next black box, then break
    else if(is.na(col[i])){
      bottom_box <- i-1
      break
    }
  }
  #identify indices using the left and right boxes
  clue_matrix[,depth][top_box:bottom_box] <<- word
}

#reads a word from global_var clue_matrix
read_word <- function(depth, type = 'list'){
  #bad solution! I need to fix this later, but I'm tired now
  word <- black_box_word(clue_matrix[,depth],3)
  if(type == 'str'){
    word <- paste(word,collapse = '')
  }
  return(word)
}

#remove a word from global_var clue_matrix
rm_word <- function(depth){
  col <- clue_matrix[,depth]
  col[!is.na(col)] <- ""
  clue_matrix[,depth] <<- col
}

#gets word at index between black boxes. used with apply, so input is just a row
#ex. c("a","",NA)
# returns, c("a","")
black_box_word <- function(row, depth){
  left_box <- 1
  right_box <- length(row)
  #at depth, check to see if that cell is a black box
  if(is.na(row[depth])){
    return(NULL)
  }
  for(i in 1:length(row)){
    #look for first black box until I reach depth
    if(is.na(row[i]) & i <= depth){
      left_box <- i+1
    }
    #past depth, find the next black box, then break
    else if(is.na(row[i]) & i > depth){
      right_box <- i-1
      break
    }
  }
  #identify indices using the left and right boxes
  row[left_box:right_box]
}
```


```{r}
#function to take a list of chars and NAs (black squares) and return the list to evaluate
clue_matrix <<- matrix(list(""),nrow=3,ncol=3,byrow = FALSE)
clue_matrix[3,1] <- NA
clue_matrix[1,3] <- NA

write_word('hmmm',depth=5,type='str')

black_box_word(c(NA,"a","t","e",NA,"a","",NA),8)
read_word(1,'str')
```

```{r}
#called by main -- find the next word
find_word <- function(working_dict,depth,clues){
  i <- 1
  while (i <= length(working_dict)) {
    if(is.null(working_dict[[1]])){break}
    word <- working_dict[[i]]
    split_word <- strsplit(word,"")[[1]]
    if(word %in% clues){
      i <- i+1
      next
    }
    clues <- append(clues,word)
    write_word(word,depth,type='str')
    across_words <- c()
    for(j in 1:ncol(clue_matrix)){
      across <- black_box_word(clue_matrix[j,],depth)
      if(!is.null(across)){
        across_words <- append(across_words,list(across))
      }
    }
    try <- sapply(across_words, test_word, clues)
    if(!FALSE %in% try){
      if((i+1)> length(working_dict)){
        return(list(working_dict[1],list(list(NULL)),TRUE))
      } else {
        return(list(working_dict[1],list(working_dict[(i+1):length(working_dict)]),TRUE))
      }
    }
    clues <- clues[1:length(clues)-1]
    for (k in 1:length(across_words)) {
      if(try[k] == TRUE){next}
      letter <- split_word[k]
      working_dict <- working_dict[sapply(working_dict, subset_dict, letter, k)]
      if(length(working_dict) == 0){
        break
      }
    }
    rm_word(depth)
    i <- 1
  }
  return(c(FALSE,FALSE,FALSE))
}

#called by find_word -- for a single word, test all possible across combinations to detect if puzzle is still valid
test_word <- function(frag,clues){
  req_char <- length(frag)
  frag <- paste(frag[frag != ""],collapse='')
  frag_possibilities <- frag_hash[[frag]]
  if(length(frag_possibilities[!frag_possibilities %in% clues][nchar(frag_possibilities) == req_char]) > 0){
    return(TRUE)
  } else {
    return(FALSE)
  }
}

#called by find_word -- identify whether the word in dict can be removed based on result from test_word 
subset_dict <- function(word, letter, pos){
  word <- strsplit(word,"")[[1]]
  if(word[pos] == letter){
    FALSE
  } else {
    TRUE
  }
}


```

```{r}
#experimenting with memory for time savings
explode_dict <- function(dict_all){
  do.call(c,lapply(dict_all, explode_word))
}
                   
explode_word <- function(x){
  split_out <- c()
  for (i in 1:nchar(x)){
    split_out <- append(split_out, substr(x,1,i))
  }
  return(split_out)
}

char_to_num <- function(x){
  if(x == ""){return(1)}
  as.numeric(charToRaw(x))-95
}

# need this to be an n-dimensional array, where at each index, I have saved a list of all possible words that start with the fragment represented by that index.
populate_frag_array <- function(dict) {
  frag_hash <- hash()
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      .set(frag_hash, frag, c(frag_hash[[ frag ]],word))
    }
  }
  return(frag_hash)
}
```

```{r}
slice_dict <- function(dict){
  stack_dict <- c()
  col_lengths <- apply(clue_matrix, 2, function(x){length(x[!is.na(x)])})
  for(i in 1:ncol(clue_matrix)){
    stack_dict <- append(stack_dict, list(dict[[i]][nchar(dict[[i]]) == col_lengths[i]]))
  }
  return(stack_dict)
}
```

```{r}
main <- function(){
  clues <- read_word(1, type = 'str')
  while(length(clues) != dim){
    depth <- length(clues) + 1
    search_tpl <- find_word(stack_dict[[depth]],depth,clues)
    if (search_tpl[[3]][[1]] == FALSE) {
      stack_dict[[depth]] <- stack_dict_mstr[[depth]]
      depth <- depth-1
      if(depth == 1){
        #rand_word <- sample(stack_dict[[1]], 1, FALSE)[[1]]
        clues <- stack_dict[[1]][[1]]
        write_word(clues, depth, type = 'str')
        stack_dict[[1]] <- stack_dict[[1]][2:length(stack_dict[[1]])]
        message(paste(length(stack_dict[[1]])))
      } else {
        if(depth == 2){message(paste(length(stack_dict[[depth]])))}
        clues <- clues[1:depth-1]
        rm_word(depth)
      }
    } else {
      stack_dict[[depth]] <- search_tpl[[2]][[1]]
      clues <- append(clues, search_tpl[[1]][[1]])
    }
  }
  return(clue_matrix)
}
```

```{r}
#load peter broda word list
pb_words_txt <- read.delim(file = 'C:\\Users\\jakes\\Documents\\R\\xword-generator\\peter-broda-wordlist__scored.txt')
pb_words <- data.frame(do.call(rbind, sapply(pb_words_txt, str_split, ";"))) %>% 
  filter(X2 > 70) %>% 
  select(-X2) %>% 
  dplyr::rename('word' = 'X1')
```


```{r}
# global vars...

init_global_vars <- function(seed,dim){
  

  frags <<- explode_dict(dict_all)
  
}

# for testing...
frag_hash <<- populate_frag_array(dict_all)#################################
dim<-6
dict_all <<- dict_init(dim)
stack_dict <<- slice_dict(rep(list(dict_all),dim))
stack_dict_mstr <<- stack_dict

seed<-'xxxxxx'
clue_matrix <- matrix("",nrow=dim,ncol=dim,byrow = FALSE)
clue_matrix[1,1] <- NA
clue_matrix[6,6] <- NA
write_word(seed,1,'str')
clue_matrix

#     [,1] [,2] [,3] [,4] [,5]
# [1,] "c"  "l"  "a"  "s"  "p"
# [2,] "r"  "i"  "v"  "e"  "r"
# [3,] "a"  "t"  "o"  "n"  "e"
# [4,] "s"  "h"  "i"  "n"  "e"
# [5,] "s"  "e"  "d"  "a"  "n"
  

init_global_vars(clue_matrix,blk_sqrs,dim)
start_time <- Sys.time()
main()
end_time <- Sys.time()
end_time - start_time
```

```{r}
start <- Sys.time()
brute_force(5)
end <- Sys.time()
end - start
```

```{r}
puzzle_master <<- c()

slice_dict <- function(dict_all){
  do.call(c,lapply(dict_all, strsplit, ""))
}

bf_tester <- function(bf_mat, dim) {
  clues <- apply(bf_mat, 2, paste, collapse = "")
  valid <- apply(bf_mat, 1, bf_try, clues, dim)
  if(!FALSE %in% valid){
    puzzle_master <<- bf_mat
  }
}

bf_try <- function(bf_row, clues, dim){
  mat_index <- matrix(sapply(bf_row,char_to_num), nrow = 1, ncol = dim)
  frag_possibilities <- frag_array[mat_index][[1]]
  if(length(frag_possibilities[!frag_possibilities %in% clues]) > 0){
    return(TRUE)
  } else {
    return(FALSE)
  }
}

brute_force <- function(dim = 5){
  slices <<- slice_dict(dict_init(dim))
  for (word1 in slices) {
    for (word2 in slices) {
      for (word3 in slices) {
        for (word4 in slices) {
          for (word5 in slices) {
            bf_tester(cbind(word1,word2,word3,word4,word5), dim)
            if(!is.null(puzzle_master)){
              return(puzzle_master)
            }
          }
        }
      }
    }
  }
}
```




