---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
library(profvis)
library(gtools)
library(hash)
```

```{r}
#compute the score of a word by the weighting of the table
score_word <- function(word,freq){
  char_list <- strsplit(word,"")[[1]]
  score<-c(rep(0,length(char_list)))
  for (i in 1:length(char_list)){
    for (j in 1:length(char_list)) {
      score[i] <- score[i] + freq[[i]][match(char_list[[j]], freq[[i]]$x),2]
    }
  }
  return(score)
}

#score every word based on frequency of letter positions
scorecard_init <- function(dict, freq, dim){
  scorecard <- data.frame(cbind(dict, do.call(rbind, data.frame(lapply(dict, score_word, freq)))))
  #rownames(scorecard) <- NULL
  #scorecard$word <- as.character(scorecard$word)
  scorecard <- scorecard %>% mutate_at(c(1:dim+1),function(x){as.numeric(as.character(x))})
  return(scorecard)
}

#initialize the dictionary
dict_init <- function(dim, wl = NULL){
  if(is.null(wl)){
    full_dict <- qdapDictionaries::DICTIONARY
  } else {
    full_dict <- wl
  }
  dict <- mutate(full_dict, char_num = nchar(word)) %>% 
    filter(char_num <= dim)
  dict <- dict$word
  dict <- tolower(dict)
  dict <- dict[stringi::stri_detect_regex(dict,"^[a-z]+$")]
  return(dict)
}

#for each column in the puzzle, create a dict list ordered by score
gen_score_dict <- function(scorecard) {
  scored_dict <- c()
  for(i in 1:(ncol(scorecard)-1)) {
    score_col <- data.frame(word = scorecard[,1], score = scorecard[,i+1]) %>% 
      arrange(desc(score))
    scored_dict <- append(scored_dict,list(as.character(score_col[,1])))
  }
  return(lapply(scored_dict, function(x){lapply(x, function(y){strsplit(y,"")[[1]]})}))
}
 
#generate a frequency table showing how likely a given word is to appear in a square
freq_init <- function(dict){
  freq <- t(data.frame(lapply(dict, strsplit, "")))
  freq <- apply(freq, 2, function(x){data.frame(table(x)[order(table(x), decreasing = TRUE)])})
  return(freq)
}
```

```{r}
#writes a word to global_var clue_matrix
write_word <- function(word, depth, num = 1, type = 'list'){
  if (type == 'str') {
    word <- strsplit(word,"")[[1]]
  }
  col <- clue_matrix[,depth]
  write_pos <- c()
  if(!is.na(col[1])){write_pos <- 1}
  for(i in 2:length(col)) {
    if(!is.na(col[i]) & is.na(col[i-1])) {
      write_pos <- c(write_pos,i)
    }
  }
  pos <- write_pos[num]
  for (i in 1:length(word)) {
    clue_matrix[pos,depth] <<- word[i]
    pos <- pos + 1
  }
}

#reads a word from global_var clue_matrix
read_word <- function(depth, num = 1, dir = 1, type = 'list'){ #if dir = 2, then read across
  if(dir == 1) {
    col <- clue_matrix[,depth]
  } else {
    col <- clue_matrix[depth,]
  }
  pos <- c()
  if(!is.na(col[1])){pos <- 1}
  for(i in 2:length(col)) {
    if(!is.na(col[i]) & is.na(col[i-1])) {
      pos <- c(pos,i)
    }
  }
  pos <- pos[num]
  reader <- c()
  while(!is.na(col[pos]) & pos <= length(col)) {
    reader <- append(reader, col[pos])
    pos <- pos + 1
  }
  if(type == 'str'){
    reader <- paste(reader, collapse ='')
  }
  return(reader)
}

#remove a word from global_var clue_matrix
rm_word <- function (depth, num = 1) {
  col <- clue_matrix[,depth]
  rm_pos <- c()
  if(!is.na(col[1])){rm_pos <- 1}
  for(i in 2:length(col)) {
    if(!is.na(col[i]) & is.na(col[i-1])) {
      rm_pos <- c(rm_pos,i)
    }
  }
  pos <- rm_pos[num]
  while(!is.na(col[pos]) & pos <= length(col)) {
    clue_matrix[pos,depth] <<- ""
    pos <- pos + 1
  }
}
```

```{r}
subset_dict <- function(across, req_char, dict, down, depth){
  valid_list <- c()
  
  ### no duplicates possible
  if(rlang::is_empty(down[substr(down,1,1) %in% substr(across,1,1)])){
    for(i in 1:length(across)){
      valid_list <- append(valid_list, list(names(frag_hash[[paste(across[i],req_char[i],sep='')]]$valid)))
    }
  }
  ### if there is a risk of validating a duplicate across word
  else {
    for(i in 1:length(across)){
      words <- frag_hash[[paste(across[i],req_char[i],sep='')]]$words
      words  <- words[!words %in% down]
      if(rlang::is_empty(words)) {
        words <- NA
      } else {
        valid <- names(table(sapply(words, stringi::stri_sub, depth, depth)))
      }
      valid_list <- append(valid_list, list(valid))
    }
  }
  #limit dict to only valid words
  for (i in 1:length(valid_list)){
    dict <- dict[substr(dict,i,i) %in% valid_list[[i]]]
  }
  return(dict)
}

update_across <- function(depth){
  across_words <- c()
  for(i in 1:nrow(clue_matrix)){
    if(!is.na(clue_matrix[i,depth])) {
      across_words <- append(across_words, read_word(i, num = 1, dir = 2, type = 'str'))
    }
  }
  return(across_words)
}

main <- function(){
  req_char <- rep(dim,dim)
  down <- read_word(1, num = 1, dir = 1, type = 'str')
  depth <- 2
  
  while(depth <= dim){
    
    if(depth == 1){message(paste(length(stack_dict[[depth]])))}
    across <- update_across(depth)
    stack_dict[[depth]] <- subset_dict(across,req_char,stack_dict[[depth]],down,depth) #returns a list of all valid words
    stack_dict[[depth]][!stack_dict[[depth]] %in% down] #remove existing clues
    
    for(i in depth:1){
      if(rlang::is_empty(stack_dict[[i]])){ #out of dict words at this level
        if(depth ==1){browser()}
        rm_word(depth,num = 1)
        stack_dict[[i]] <- mstr_dict[[i]]
        depth <- depth - 1
        if(depth == 0) {return(clue_matrix)} #search has failed
        down <- down[1:(length(down)-1)]
      } else {
        break
      }
    }
    
    candidate <- stack_dict[[depth]][1]
    write_word(candidate, depth, num = 1, type = 'str')
    down <- c(down, candidate)
    stack_dict[[depth]] <- stack_dict[[depth]][-1] # remove the chosen word from dict
    depth <- depth + 1
  }
  return(clue_matrix)
}
```

```{r}
dim<-5
clue_matrix <- matrix("",nrow=dim,ncol=dim,byrow = FALSE)
dict_all <<- dict_init(dim)
stack_dict <<- slice_dict(rep(list(dict_all),dim))
mstr_dict <<- stack_dict
#frag_hash <<- populate_frag_hash(dict_all,dim)

seed<-'spasm'
write_word(seed,1,1,'str')
clue_matrix
```

```{r}
start_time <- Sys.time()
main()
end_time <- Sys.time()
end_time - start_time
```

```{r}
explode_word <- function(x){
  split_out <- c()
  for (i in 1:nchar(x)){
    split_out <- append(split_out, substr(x,1,i))
  }
  return(split_out)
}

slice_dict <- function(dict){
  stack_dict <- c()
  col_lengths <- apply(clue_matrix, 2, function(x){length(x[!is.na(x)])})
  for(i in 1:ncol(clue_matrix)){
    stack_dict <- append(stack_dict, list(dict[[i]][nchar(dict[[i]]) == col_lengths[i]]))
  }
  return(stack_dict)
}

# need this to be an n-dimensional array, where at each index, I have saved a list of all possible words that start with the fragment represented by that index.
populate_frag_hash <- function(dict,dim) {
  #initialize
  frag_hash <- hash()
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      for (i in nchar(frag):dim){
        pathfinder <- list(words = c(), valid = c())
        .set(frag_hash, paste(frag,i,sep=''), pathfinder)
      }
    }
  }
  #populate
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      for (i in nchar(frag):dim){
        if(nchar(word) == i){
          words_list <- append(frag_hash[[ paste(frag,i,sep='') ]]$words, word)
          pathfinder <- list(words = words_list, valid = c())
          .set(frag_hash, paste(frag,i,sep=''), pathfinder)
        }
      }
    }
  }
  #calculate
  keys <- hash::keys(frag_hash)
  for (key in keys) {
    next_index <- nchar(gsub("^([a-z]+)+[0-9]+$", "\\1", key))+1
    words_list <- frag_hash[[ key ]]$words
    if(is.null(words_list)){
      valid_list <- NULL
    } else {
      valid_list <- table(sapply(words_list, stringi::stri_sub, next_index, next_index))
    }
    pathfinder <- list(words = words_list, valid = valid_list)
    .set(frag_hash, key, pathfinder)
  }
  return(frag_hash)
}
```