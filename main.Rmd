---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
```

```{r}
#compute the score of a word by the weighting of the table
score_word <- function(word,freq){
  char_list <- strsplit(word,"")[[1]]
  score <- c(down1 = 0, down2 = 0, down3 = 0, down4 = 0)
  for (i in 1:length(char_list)){
    for (j in 1:length(score)) {
      score[i] <- score [i] + freq[[i]][match(char_list[[j]], freq[[i]]$x),2]
    }
  }
  return(score)
}

#score every word based on frequency of letter positions
scorecard_init <- function(dict, freq){
  scorecard <- data.frame(cbind(dict, do.call(rbind, data.frame(lapply(dict, score_word, freq)))))
  rownames(scorecard) <- NULL
  colnames(scorecard) <- c('word','down1','down2','down3','down4')
  scorecard$word <- as.character(scorecard$word)
  scorecard <- scorecard %>% mutate_at(c(2:5),function(x){as.numeric(as.character(x))})
  return(scorecard)
}

#initialize the dictionary
dict_init <- function(){
  full_dict <- qdapDictionaries::DICTIONARY
  dict3 <- mutate(full_dict, nchar = nchar(word)) %>% 
    filter(nchar == 4)
  dict <- dict3$word
  return(dict)
}

#for each column in the puzzle, create a dict list ordered by score
score_dict <- function(scorecard) {
  scored_dict <- c()
  for(i in 1:(ncol(scorecard)-1)) {
    score_col <- data.frame(word = scorecard[,1], score = scorecard[,i+1]) %>% 
      arrange(desc(score))
    scored_dict <- append(scored_dict,list(as.character(score_col[,1])))
  }
  return(scored_dict)
}

dict_avail_words <- function(clues, score_dict) {
  avail_words <- score_dict[[1]][!score_dict[[1]] %in% clues]
  return(avail_words)
}
 
#generate a frequency table showing how likely a given word is to appear in a square
freq_init <- function(dict){
  freq <- t(data.frame(lapply(dict, strsplit, "")))
  freq <- apply(freq, 2, function(x){data.frame(table(x)[order(table(x), decreasing = TRUE)])})
  return(freq)
}
#initialize the puzzle
puzzle_init <- function(){
  puzzle <- data.frame(down1 = rep(NA,4), down2 = rep(NA,4), down3 = rep(NA,4), down4 =  rep(NA,4))
  return(puzzle)
}

#initialize the stack
stack_init <- function(){
  stack <- c()
}

#push a line to the stack
push <- function(stack,index, word, puzzle, dict){
  dict <- lapply(dict, function(x){x <- x[x != word]})
  stack <- append(stack,list(list(index, word, data.frame(puzzle), dict[dict != word])))
  return(stack)
}

#pop the most recent line from the stack and remove the word from the popped stack from the preceding line's dictionary
pop <- function(stack){
  remove_word <- observe('word',stack)
  stack <- stack[1:length(stack)-1]
  dict <- observe('dict',stack)
  stack[[length(stack)]][[4]] <- lapply(dict, function(x){x <- x[x != remove_word]})
  return(stack)
}

observe <- function(which, stack){
  if(which == 'index'){
    which <- 1
  } else if(which == 'word'){
    which <- 2
  } else if(which == 'puzzle'){
    which <- 3
  } else if(which == 'dict'){
    which <- 4
  } else {
    which <- 100 #crash the program
  }
  return(stack[[length(stack)]][[which]])
}

#find the indices of the next line to gen for the puzzle. uses the stack to find available indices, returns a df index$across, index$down
next_line <- function(puzzle,stack){
  indices <- c()
  for(i in 1:length(stack)){
    indices <- unlist(append(indices,stack[[i]][[1]]))
  }
  # puzzle_cols <- seq(1:ncol(puzzle))
  # remaining_cols <- puzzle_cols[!puzzle_cols %in% indices]
  # if(length(remaining_cols) > 1) {
  #   line <- sample(remaining_cols,1)
  # } else if(length(remaining_cols == 1)) {
  #   line <- remaining_cols
  # } 
  if(length(indices) < ncol(puzzle)) {
    line <- length(indices) + 1
  } else {
    line <- 'puzzle is complete'
  }
  return(line)
}

#look through the across rows and make sure that the puzzle is still viable
test_puzzle <- function(clue, avail_words, puzzle, depth){
  puzzle <- write_word(clue,puzzle,depth)
  apply(puzzle, 1, function(x){
      x[is.na(x)] <- '.'
      matches <- lapply(avail_words,str_detect,regex(paste(unlist(x), collapse='')))
      pass <- ifelse(length(matches[matches == TRUE]) > 0, TRUE, FALSE)
    })
}

#find the next word to be added to the puzzle using the frequency table
#look for the best word where the frequency serves both across and down directions on puzzle
find_word <- function(clues,stack_dict,depth){
  puzzle <- puzzle_init()
  for(i in 1:(depth-1)){
    puzzle <- write_word(clues[i],puzzle,i)
  }
  for(i in 1:length(stack_dict)) {
    try <- test_puzzle(stack_dict[i],stack_dict,puzzle,depth)
    if(!FALSE %in% try){
      return(c(stack_dict[i],list(stack_dict[i+1:length(stack_dict)])))
    }
  }
  return(FALSE)
}

#write a word into the puzzle at a given index
write_word <- function(word, puzzle, depth){
  word <- strsplit(word, "")[[1]]
  puzzle[,depth] <- word
  return(puzzle)
}

```

```{r}
stack <- stack_init()
dict_all <- dict_init()
freq <- freq_init(dict_all)
scorecard <- scorecard_init(dict_all,freq)
score_dict <- score_dict(scorecard)
```

```{r}
# for testing...
seed <- 'sale'
```

```{r}
execution_log <- data.frame(stack_lvl = NA, dict_length = NA, word = NA, down1 = NA, down2 = NA, down3 =  NA)
```

```{r}
main <- function(seed,score_dict){
  clues <- c(seed)
  while(length(clues) != 4){
    depth <- length(clues)+1
    stack_dict <- score_dict[[depth]]
    stack_dict <- stack_dict[!stack_dict %in% clues]
    search_tpl <- find_word(clues,stack_dict,depth)
    stack_dict <- search_tpl[[2]]
    clues <- append(clues, search_tpl[[1]])
  }
  return(clues)
}

clues <-  main(seed,score_dict)

xword <-puzzle_init()
for(i in 1:length(clues)){
  xword <- write_word(clues[i], xword, i)
}
xword
```
