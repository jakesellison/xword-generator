---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
library(profvis)
library(gtools)
library(hash)
`%+=%` = function(e1,e2) eval.parent(substitute(e1 <- e1 + e2))
```

```{r}
#compute the score of a word by the weighting of the table
score_word <- function(word,freq){
  char_list <- strsplit(word,"")[[1]]
  score<-c(rep(0,length(char_list)))
  for (i in 1:length(char_list)){
    for (j in 1:length(char_list)) {
      score[i] <- score[i] + freq[[i]][match(char_list[[j]], freq[[i]]$x),2]
    }
  }
  return(score)
}

#score every word based on frequency of letter positions
scorecard_init <- function(dict, freq, dim){
  scorecard <- data.frame(cbind(dict, do.call(rbind, data.frame(lapply(dict, score_word, freq)))))
  #rownames(scorecard) <- NULL
  #scorecard$word <- as.character(scorecard$word)
  scorecard <- scorecard %>% mutate_at(c(1:dim+1),function(x){as.numeric(as.character(x))})
  return(scorecard)
}

#initialize the dictionary
dict_init <- function(dim, wl = NULL){
  if(is.null(wl)){
    full_dict <- qdapDictionaries::DICTIONARY
  } else {
    full_dict <- wl
  }
  dict <- mutate(full_dict, char_num = nchar(word)) %>% 
    filter(char_num <= dim)
  dict <- dict$word
  dict <- tolower(dict)
  dict <- dict[stringi::stri_detect_regex(dict,"^[a-z]+$")]
  return(dict)
}

#for each column in the puzzle, create a dict list ordered by score
gen_score_dict <- function(scorecard) {
  scored_dict <- c()
  for(i in 1:(ncol(scorecard)-1)) {
    score_col <- data.frame(word = scorecard[,1], score = scorecard[,i+1]) %>% 
      arrange(desc(score))
    scored_dict <- append(scored_dict,list(as.character(score_col[,1])))
  }
  return(lapply(scored_dict, function(x){lapply(x, function(y){strsplit(y,"")[[1]]})}))
}
 
#generate a frequency table showing how likely a given word is to appear in a square
freq_init <- function(dict){
  freq <- t(data.frame(lapply(dict, strsplit, "")))
  freq <- apply(freq, 2, function(x){data.frame(table(x)[order(table(x), decreasing = TRUE)])})
  return(freq)
}
```

```{r}
# considerations for implementing black squares:
# 
#   dim can't be the measure that I test by, I will need a new way to measure the length of word to choose*
#   
#   should create a static matrix that I update, and I pass along my current pos rather than cbind on rows
# 
#   > get a down word that is correct length
#     - it can start one (or more) char short
#     - it can end one (or more) char short
#   > test appropriately for across word. 
#     - it can end early
#     - it can start early
#     
#   I should look down the col and determine the length of word to use
#   THEN add that word to the matrix, offsetting by black squares
#   THEN run test_word
#     IN TEST WORD if 
  
```

```{r}
#writes a word to global_var clue_matrix
write_word <- function(word, depth, num = 1, type = 'list'){
  if (type == 'str') {
    word <- strsplit(word,"")[[1]]
  }
  col <- clue_matrix[,depth]
  write_pos <- c()
  if(!is.na(col[1])){write_pos <- 1}
  for(i in 2:length(col)) {
    if(!is.na(col[i]) & is.na(col[i-1])) {
      write_pos <- c(write_pos,i)
    }
  }
  pos <- write_pos[num]
  for (i in 1:length(word)) {
    clue_matrix[pos,depth] <<- word[i]
    pos <- pos + 1
  }
}

#reads a word from global_var clue_matrix
read_word <- function(depth, num = 1, dir = 1, type = 'list'){ #if dir = 2, then read across
  if(dir == 1) {
    col <- clue_matrix[,depth]
  } else {
    col <- clue_matrix[depth,]
  }
  write_pos <- c()
  if(!is.na(col[1])){write_pos <- 1}
  for(i in 2:length(col)) {
    if(!is.na(col[i]) & is.na(col[i-1])) {
      write_pos <- c(write_pos,i)
    }
  }
  pos <- write_pos[num]
  reader <- c()
  while(!is.na(col[pos]) & pos <= length(col)) {
    reader <- append(reader, col[pos])
    pos <- pos + 1
  }
  if(type == 'str'){
    reader <- paste(reader, collapse ='')
  }
  return(reader)
}

#remove a word from global_var clue_matrix
rm_word <- function (depth,num = 1) {
  col <- clue_matrix[,depth]
  rm_pos <- c()
  if(!is.na(col[1])){rm_pos <- 1}
  for(i in 2:length(col)) {
    if(!is.na(col[i]) & is.na(col[i-1])) {
      rm_pos <- c(rm_pos,i)
    }
  }
  pos <- rm_pos[num]
  while(!is.na(col[pos]) & pos <= length(col)) {
    clue_matrix[pos,depth] <<- ""
    pos <- pos + 1
  }
}
read_word(depth = 5, num = 1, dir = 2,'list')
is.na(clue_matrix[3,2])
clue_matrix
```

```{r}
#called by main -- find the next word
find_word <- function(working_dict,depth,clues){
  i <- 1
  while (i <= length(working_dict)) {
    if(is.null(working_dict[[1]])){break}
    word <- working_dict[[i]]
    split_word <- strsplit(word,"")[[1]]
    if(word %in% clues){
      i <- i+1
      next
    }
    clues <- append(clues,word)
    write_word(word, depth, num = 1, type='str')
    across_words <- c()
    for(j in 1:nrow(clue_matrix)){
      if(!is.na(clue_matrix[j,depth])) {
        across_words <- append(across_words, list(read_word(j, num = 1, dir = 2, type = 'list')))
      }
    }
    try <- sapply(across_words, test_word, clues)
    if(!FALSE %in% try){
      if((i+1)> length(working_dict)){
        return(list(working_dict[1],list(list(NULL)),TRUE))
      } else {
        return(list(working_dict[1],list(working_dict[(i+1):length(working_dict)]),TRUE))
      }
    }
    clues <- clues[1:length(clues)-1]
    for (k in 1:length(across_words)) {
      if(try[k] == TRUE){next}
      letter <- split_word[k]
      working_dict <- working_dict[sapply(working_dict, subset_dict, letter, k)]
      if(length(working_dict) == 0){
        break
      }
    }
    rm_word(depth, num = 1)
    i <- 1
  }
  return(c(FALSE,FALSE,FALSE))
}

#called by find_word -- for a single word, test all possible across combinations to detect if puzzle is still valid
test_word <- function(frag,clues){
  req_char <- length(frag)
  frag <- paste(frag[frag != ""],collapse='')
  frag_possibilities <- frag_hash[[frag]]
  if(length(frag_possibilities[!frag_possibilities %in% clues & nchar(frag_possibilities) == req_char]) > 0){
    return(TRUE)
  } else {
    return(FALSE)
  }
}

#called by find_word -- identify whether the word in dict can be removed based on result from test_word 
subset_dict <- function(word, letter, pos){
  word <- strsplit(word,"")[[1]]
  if(word[pos] == letter){
    FALSE
  } else {
    TRUE
  }
}
```

```{r}
#experimenting with memory for time savings
explode_dict <- function(dict_all){
  do.call(c,lapply(dict_all, explode_word))
}
                   
explode_word <- function(x){
  split_out <- c()
  for (i in 1:nchar(x)){
    split_out <- append(split_out, substr(x,1,i))
  }
  return(split_out)
}

char_to_num <- function(x){
  if(x == ""){return(1)}
  as.numeric(charToRaw(x))-95
}

# need this to be an n-dimensional array, where at each index, I have saved a list of all possible words that start with the fragment represented by that index.
populate_frag_array <- function(dict) {
  frag_hash <- hash()
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      .set(frag_hash, frag, c(frag_hash[[ frag ]],word))
    }
  }
  return(frag_hash)
}
```

```{r}
slice_dict <- function(dict){
  stack_dict <- c()
  col_lengths <- apply(clue_matrix, 2, function(x){length(x[!is.na(x)])})
  for(i in 1:ncol(clue_matrix)){
    stack_dict <- append(stack_dict, list(dict[[i]][nchar(dict[[i]]) == col_lengths[i]]))
  }
  return(stack_dict)
}
```

```{r}
main <- function(){
  clues <- read_word(depth = 1, num = 1, dir = 1, type = 'str')
  while(length(clues) != dim){
    depth <- length(clues) + 1
    search_tpl <- find_word(stack_dict[[depth]],depth,clues)
    if (search_tpl[[3]][[1]] == FALSE) {
      stack_dict[[depth]] <- stack_dict_mstr[[depth]]
      depth <- depth-1
      if(depth == 1){
        clues <- stack_dict[[1]][[1]]
        write_word(clues, depth, num = 1, type = 'str')
        stack_dict[[1]] <- stack_dict[[1]][2:length(stack_dict[[1]])]
        message(paste(length(stack_dict[[1]])))
      } else {
        if(depth == 2){message(paste(length(stack_dict[[depth]])))}
        clues <- clues[1:depth-1]
        rm_word(depth, num = 1)
      }
    } else {
      stack_dict[[depth]] <- search_tpl[[2]][[1]]
      clues <- append(clues, search_tpl[[1]][[1]])
    }
  }
  return(clue_matrix)
}
```

```{r}
dim<-7
clue_matrix <- matrix("",nrow=dim,ncol=dim,byrow = FALSE)
clue_matrix[1,1] <- NA
clue_matrix[2,1] <- NA
clue_matrix[1,2] <- NA
clue_matrix[7,1] <- NA
clue_matrix[6,1] <- NA
clue_matrix[7,2] <- NA
clue_matrix[1,7] <- NA
clue_matrix[1,6] <- NA
clue_matrix[2,7] <- NA
clue_matrix[7,7] <- NA
clue_matrix[7,6] <- NA
clue_matrix[6,7] <- NA
dict_all <<- dict_init(dim)
stack_dict <<- slice_dict(rep(list(dict_all),dim))
stack_dict_mstr <<- stack_dict
frag_hash <<- populate_frag_array(dict_all)

seed<-'hmm'
write_word(seed,1,1,'str')
clue_matrix
```

```{r}
start_time <- Sys.time()
main()
end_time <- Sys.time()
end_time - start_time
```

```{r}
start <- Sys.time()
brute_force(5)
end <- Sys.time()
end - start
```

```{r}
puzzle_master <<- c()

slice_dict <- function(dict_all){
  do.call(c,lapply(dict_all, strsplit, ""))
}

bf_tester <- function(bf_mat, dim) {
  clues <- apply(bf_mat, 2, paste, collapse = "")
  valid <- apply(bf_mat, 1, bf_try, clues, dim)
  if(!FALSE %in% valid){
    puzzle_master <<- bf_mat
  }
}

bf_try <- function(bf_row, clues, dim){
  mat_index <- matrix(sapply(bf_row,char_to_num), nrow = 1, ncol = dim)
  frag_possibilities <- frag_array[mat_index][[1]]
  if(length(frag_possibilities[!frag_possibilities %in% clues]) > 0){
    return(TRUE)
  } else {
    return(FALSE)
  }
}

brute_force <- function(dim = 5){
  slices <<- slice_dict(dict_init(dim))
  for (word1 in slices) {
    for (word2 in slices) {
      for (word3 in slices) {
        for (word4 in slices) {
          for (word5 in slices) {
            bf_tester(cbind(word1,word2,word3,word4,word5), dim)
            if(!is.null(puzzle_master)){
              return(puzzle_master)
            }
          }
        }
      }
    }
  }
}
```




