---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
library(profvis)
library(gtools)
library(hash)
library(readxl)
library(tcltk)
options(expressions = 500000)
```

```{r}
get_grid <- function(){
  grid <- readxl::read_xlsx('C:\\Users\\jakes\\Documents\\R\\xword-generator\\xword_grid.xlsx', col_names = FALSE)
  puzz <- c()
  for(i in 1:ncol(grid)){
    puzz <- c(puzz, unlist(grid[,i]))
  }
  return(unname(puzz))
}

get_word_lens <- function(){
  grid <- readxl::read_xlsx('C:\\Users\\jakes\\Documents\\R\\xword-generator\\xword_grid.xlsx', col_names = FALSE)
  word_lens <- c()
  list <- c()
  for(i in 1:ncol(grid)){
    for(element in grid[,i]){
      list <- sapply(strsplit(paste(element,collapse=''),'NA'),nchar)
    }
    word_lens <- c(word_lens, list)
  }
  return(word_lens[word_lens != 0])
}

format_puzzle <- function(){
  tail <- 1
  head <- 1
  mat <- matrix(NA, ncol = 1, nrow = dims)
  for(i in 1:length(puzz)){
    if(i %% dims == 0){
      head <- i
      mat <- cbind(mat, puzz[tail:head])
      tail <- i+1
    }
  }
  return(mat[,2:ncol(mat)])
}
```


```{r}
#initialize the dictionary
dict_init <- function(word_len_list){
  dict <- qdapDictionaries::DICTIONARY
  pb_words <- read.delim('peter-broda-wordlist__scored.txt')
  pb_words <- data.frame(do.call(rbind, sapply(pb_words, strsplit, ";"))) %>% 
    dplyr::rename('word' = 'X1', 'score' = 'X2') %>% 
    filter(score > 75)
  dict <- bind_rows(dict,pb_words) %>% 
    select(word) %>%
    distinct(word)
  dict <- dict %>% 
    mutate(char_num = nchar(word),
           word = tolower(word)) %>% 
    filter(stringi::stri_detect_regex(word,"^[a-z]+$"))
  stack_dict <- c()
  for (k in 1:length(word_len_list)) {
    stack_dict <- append(stack_dict, list(sample(filter(dict, char_num == word_len_list[k])$word)))
  }
  return(stack_dict)
}
```

```{r}
explode_word <- function(x){
  split_out <- c()
  for (i in 1:nchar(x)){
    split_out <- append(split_out, substr(x,1,i))
  }
  return(split_out)
}

slice_dict <- function(dict){
  stack_dict <- c()
  col_lengths <- apply(clue_matrix, 2, function(x){length(x[!is.na(x)])})
  for(i in 1:ncol(clue_matrix)){
    stack_dict <- append(stack_dict, list(dict[[i]][nchar(dict[[i]]) == col_lengths[i]]))
  }
  return(stack_dict)
}

# need this to be an n-dimensional array, where at each index, I have saved a list of all possible words that start with the fragment represented by that index.
populate_frag_hash <- function(x) {
  #initialize
  dict <- qdapDictionaries::DICTIONARY %>% 
    filter(nchar(word) %in% x)
  dict <- dict$word
  frag_hash <- hash()
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      pathfinder <- list(words = c())
      .set(frag_hash, frag, pathfinder)
    }
  }
  #populate
  #browser()
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      words_list <- append(frag_hash[[ frag ]]$words, word)
      pathfinder <- list(words = words_list, valid = c())
      .set(frag_hash, frag, pathfinder)
    }
  }
  return(frag_hash)
}
```

```{r}
write_word <- function(word, depth, type = 'str'){
  #browser()
  if(type == 'str'){
    word <- strsplit(word, "")[[1]]
  }
  for(i in depth:length(puzz)){
    if(!is.na(puzz[i]) & puzz[i] == "?"){
      depth <- i
      break
    }
  }
  for(i in 0:(length(word)-1)){
    puzz[i+depth] <<- word[i+1]
  }
  depth <- depth + i
  for(i in depth:length(puzz)){
    if(!is.na(puzz[i]) & puzz[i] == "?"){
      depth <- i
      break
    }
  }
  return(depth)
}

rm_word <- function(depth){
  #browser()
  for(i in depth:0){
    if(!is.na(puzz[i]) & puzz[i] != "?"){
      depth <- i
      break
    }
  }
  rm_to <- depth - ((depth-1) %% dims)
  for(i in depth:rm_to){
    if(is.na(puzz[i])){
      i <- i + 1
      break
    } else {
      puzz[i] <<- "?"
    }
  }
  depth <- i
  for(i in depth:length(puzz)){
    if(!is.na(puzz[i]) & puzz[i] == "?"){
      depth <- i
      break
    }
  }
  return(depth)
}

#read all across words through 
read_across <- function(){
  return(unlist(lapply(seq(1,dims), function(x){
    index <- ceiling((depth+1)/dims)
    row <- puzz[seq(x,length(puzz),dims)]
    if(!is.na(row[index])){
      row[index] <- paste(row[index],'^',sep='')
    } else {
      return("")
    }
    row <- unlist(strsplit(paste(row,collapse=''),'NA'))
    for(i in 1:length(row)){
      if(stringi::stri_detect_fixed(row[i], "^")){
        return(gsub('^',"",row[i],fixed=TRUE))
      }
    }
  })))
}
```

```{r}
subset_dict <- function(across, req_char, dict, down, depth){
  #browser()
  start_index <- ifelse(depth %% dims == 0, dims, depth %% dims)
  end_index <- start_index+nchar(dict[1])-1
  across <- across[start_index:end_index]
  req_char <- sapply(across, nchar)
  across <- sapply(across, function(x){gsub('?','',x,fixed=TRUE)})
  if(rlang::is_empty(across[across != ""])){
    return(dict)
  }
  valid_list <- c()
  for(i in 1:length(across)){
    if(across[i] == ''){
      valid <- NULL
    } else {
      words <- frag_hash[[ across[i] ]]$words
      words <- words[nchar(words) == req_char[i]]
      words  <- words[!words %in% down]
      if(rlang::is_empty(words)){
        valid <- ""
      } else {
        valid <- names(table(sapply(words, stringi::stri_sub, nchar(across[i])+1, nchar(across[i])+1)))
      }
    }
    valid_list <- append(valid_list, list(valid))
  }
  #limit dict to only valid words
  for (i in 1:length(valid_list)){
    if(is.null(valid_list[[i]])){
      next
    }
    dict <- dict[substr(dict,i,i) %in% valid_list[[i]]]
  }
  return(dict)
}

main <- function(seed){
  #browser()
  puz_col <- 1
  down <- c()
  while(length(down) != length(stack_dict)){ #depth is the index progress through stack_dict
    across <- read_across()
    stack_dict[[puz_col]] <- subset_dict(across,req_char,stack_dict[[puz_col]],down,depth) #returns a list of all valid words
    stack_dict[[puz_col]][!stack_dict[[puz_col]] %in% down] #remove existing clues
    
    for(i in puz_col:1){
      if(rlang::is_empty(stack_dict[[i]])){ #out of dict words at this level
        stack_dict[[i]] <- mstr_dict[[i]]
        depth <<- rm_word(depth)
        puz_col <- puz_col - 1
        if(depth == 0) {return(clue_matrix)} #search has failed
        down <- down[-length(down)]
      } else {
        break
      }
    }
    candidate <- stack_dict[[puz_col]][1]
    stack_dict[[puz_col]] <- stack_dict[[puz_col]][-1] # remove the chosen word from dict
    depth <<- write_word(candidate, depth, type = 'str')
    down <- c(down, candidate)
    puz_col <- puz_col + 1
  }
  return(puzz)
}
```

```{r}
dims<<-15
puzz <- get_grid()
word_lens <- get_word_lens()
stack_dict <<- dict_init(word_lens)
mstr_dict <<- stack_dict
#frag_hash <<- populate_frag_hash(unique(word_lens))
depth<<-1
puzz
```

```{r}
start_time <- Sys.time()
main(seed)
end_time <- Sys.time()
end_time - start_time
```

```{r}
print_progress <- function(){
  .id <<- tcl('after', 60000, print_progress)
  print(format_puzzle())
}
print_progress()
tcl("after", "cancel", .id)
```


