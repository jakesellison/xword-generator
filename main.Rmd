---
title: "main"
output: html_document
---
```{r}
library(tidyverse)
library(qdapDictionaries)
library(profvis)
library(gtools)
library(hash)
options(expressions = 500000)
```

```{r}
#initialize the dictionary
dict_init <- function(word_len_list){
  dict <- qdapDictionaries::DICTIONARY
  dict <- dict %>% 
    mutate(char_num = nchar(word),
           word = tolower(word)) %>% 
    filter(stringi::stri_detect_regex(dict$word,"^[a-z]+$"))
  stack_dict <- c()
  for (k in 1:length(word_len_list)) {
    stack_dict <- append(stack_dict, list(sample(filter(dict, char_num == word_len_list[k])$word)))
  }
  return(stack_dict)
}
```

```{r}
explode_word <- function(x){
  split_out <- c()
  for (i in 1:nchar(x)){
    split_out <- append(split_out, substr(x,1,i))
  }
  return(split_out)
}

slice_dict <- function(dict){
  stack_dict <- c()
  col_lengths <- apply(clue_matrix, 2, function(x){length(x[!is.na(x)])})
  for(i in 1:ncol(clue_matrix)){
    stack_dict <- append(stack_dict, list(dict[[i]][nchar(dict[[i]]) == col_lengths[i]]))
  }
  return(stack_dict)
}

# need this to be an n-dimensional array, where at each index, I have saved a list of all possible words that start with the fragment represented by that index.
populate_frag_hash <- function(stack_dict) {
  #initialize
  dict <- qdapDictionaries::DICTIONARY %>% 
    filter(nchar(word) < dims)
  dict <- dict$word
  frag_hash <- hash()
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      for (i in nchar(frag):dims){
        pathfinder <- list(words = c(), valid = c())
        .set(frag_hash, paste(frag,i,sep=''), pathfinder)
      }
    }
  }
  #populate
  for (word in dict) {
    frags <- explode_word(word)
    for (frag in frags) {
      for (i in nchar(frag):dims){
        if(nchar(word) == i){
          words_list <- append(frag_hash[[ paste(frag,i,sep='') ]]$words, word)
          pathfinder <- list(words = words_list, valid = c())
          .set(frag_hash, paste(frag,i,sep=''), pathfinder)
        }
      }
    }
  }
  #calculate
  keys <- hash::keys(frag_hash)
  for (key in keys) {
    next_index <- nchar(gsub("^([a-z]+)+[0-9]+$", "\\1", key))+1
    words_list <- frag_hash[[ key ]]$words
    if(is.null(words_list)){
      valid_list <- NULL
    } else {
      valid_list <- table(sapply(words_list, stringi::stri_sub, next_index, next_index))
    }
    pathfinder <- list(words = words_list, valid = valid_list)
    .set(frag_hash, key, pathfinder)
  }
  return(frag_hash)
}
```

```{r}
write_word <- function(word, depth, type = 'str'){
  #browser()
  if(type == 'str'){
    word <- strsplit(word, "")[[1]]
  }
  for(i in depth:length(puzz)){
    if(!is.na(puzz[i]) & puzz[i] == "?"){
      depth <- i
      break
    }
  }
  for(i in 0:(length(word)-1)){
    puzz[i+depth] <<- word[i+1]
  }
  depth <- depth + i
  for(i in depth:length(puzz)){
    if(!is.na(puzz[i]) & puzz[i] == "?"){
      depth <- i
      break
    }
  }
  return(depth)
}

rm_word <- function(depth){
  #browser()
  for(i in depth:0){
    if(!is.na(puzz[i]) & puzz[i] != "?"){
      depth <- i
      break
    }
  }
  rm_to <- depth - ((depth-1) %% dims)
  for(i in depth:rm_to){
    if(is.na(puzz[i])){
      i <- i + 1
      break
    } else {
      puzz[i] <<- "?"
    }
  }
  depth <- i
  for(i in depth:length(puzz)){
    if(!is.na(puzz[i]) & puzz[i] == "?"){
      depth <- i
      break
    }
  }
  return(depth)
}

#read all across words through 
read_across <- function(){
  return(unlist(lapply(seq(1,dims), function(x){
    index <- ceiling((depth+1)/dims)
    row <- puzz[seq(x,length(puzz),dims)]
    if(!is.na(row[index])){
      row[index] <- paste(row[index],'^',sep='')
    } else {
      return("")
    }
    row <- unlist(strsplit(paste(row,collapse=''),'NA'))
    for(i in 1:length(row)){
      if(stringi::stri_detect_fixed(row[i], "^")){
        return(gsub('^',"",row[i],fixed=TRUE))
      }
    }
  })))
}
```

```{r}
subset_dict <- function(across, req_char, dict, down, depth){
  #browser()
  start_index <- ifelse(depth %% dims == 0, dims, depth %% dims)
  end_index <- start_index+nchar(dict[1])-1
  across <- across[start_index:end_index]
  req_char <- sapply(across, nchar)
  across <- sapply(across, function(x){gsub('?','',x,fixed=TRUE)})
  valid_list <- c()
  for(i in 1:length(across)){
    words <- frag_hash[[paste(across[i],req_char[i],sep='')]]$words
    words  <- words[!words %in% down]
    if(rlang::is_empty(words)) {
      valid <- NULL
    } else {
      valid <- names(table(sapply(words, stringi::stri_sub, nchar(across[i])+1, nchar(across[i])+1)))
    }
    valid_list <- append(valid_list, list(valid))
  }
  #limit dict to only valid words
  for (i in 1:length(valid_list)){
    if(is.null(valid_list[[i]])){
      next
    }
    dict <- dict[substr(dict,i,i) %in% valid_list[[i]]]
  }
  return(dict)
}

main <- function(){
  #browser()
  down <- 'sat'
  puz_col <- 1
  while(length(down) != length(stack_dict)){ #depth is the index progress through stack_dict
    
    if(depth == 2){
      message(paste(length(stack_dict[[1]])))
    }
    puz_col <- puz_col + 1
    across <- read_across()
    stack_dict[[puz_col]] <- subset_dict(across,req_char,stack_dict[[puz_col]],down,depth) #returns a list of all valid words
    stack_dict[[puz_col]][!stack_dict[[puz_col]] %in% down] #remove existing clues
    
    for(i in puz_col:1){
      if(rlang::is_empty(stack_dict[[i]])){ #out of dict words at this level
        stack_dict[[i]] <- mstr_dict[[i]]
        depth <<- rm_word(depth)
        puz_col <- puz_col - 1
        if(depth == 0) {return(clue_matrix)} #search has failed
        down <- down[-length(down)]
      } else {
        break
      }
    }
    candidate <- stack_dict[[puz_col]][1]
    stack_dict[[puz_col]] <- stack_dict[[puz_col]][-1] # remove the chosen word from dict
    depth <<- write_word(candidate, depth, type = 'str')
    down <- c(down, candidate)
  }
  return(puzz)
}
```

```{r}
dims<<-6
puzz <<- c('?','?','?','?',NA,NA,
           '?','?','?','?','?','?',
           '?','?',NA,'?','?','?',
           '?','?','?',NA,'?','?',
           '?','?','?','?','?','?',
           NA,NA,'?','?','?','?')
depth <<- write_word('star', 1, type = 'str')
stack_dict <<- dict_init(c(4,6,2,3,3,2,6,4))
mstr_dict <<- stack_dict
frag_hash <<- populate_frag_hash(stack_dict)
puzz
read_across()
```

```{r}
start_time <- Sys.time()
main()
end_time <- Sys.time()
end_time - start_time
```

